# coding: utf-8

"""
    MeshDB Data API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date, datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from pymeshdb.models.install_additional_members_inner import InstallAdditionalMembersInner
from pymeshdb.models.install_building import InstallBuilding
from pymeshdb.models.install_install_fee_billing_datum import InstallInstallFeeBillingDatum
from pymeshdb.models.install_member import InstallMember
from pymeshdb.models.install_node import InstallNode
from pymeshdb.models.status4ff_enum import Status4ffEnum
from typing import Optional, Set
from typing_extensions import Self

class PatchedInstall(BaseModel):
    """
    A  ModelSerializer MixIn which sets `NestedKeyObjectRelatedField` as the default field class to use for the foreign key fields
    """ # noqa: E501
    id: Optional[StrictStr] = None
    request_date: Optional[datetime] = None
    install_fee_billing_datum: Optional[InstallInstallFeeBillingDatum] = None
    install_number: Optional[StrictInt] = None
    status: Optional[Status4ffEnum] = Field(default=None, description="The current status of this install  * `Request Received` - Request Received * `Pending` - Pending * `Blocked` - Blocked * `Active` - Active * `Inactive` - Inactive * `Closed` - Closed * `NN Reassigned` - NN Reassigned")
    ticket_number: Optional[StrictStr] = Field(default=None, description="The ticket number of the OSTicket used to track communications with the member about this install. Note that although this appears to be an integer, it is not. Leading zeros are important, so this should be stored as a string at all times")
    install_date: Optional[date] = Field(default=None, description="The date this install was completed and deployed to the mesh")
    abandon_date: Optional[date] = Field(default=None, description="The date this install was abandoned, unplugged, or disassembled")
    unit: Optional[StrictStr] = Field(default=None, description="Line 2 of this install's mailing address")
    roof_access: Optional[StrictBool] = Field(default=False, description="True if the member indicated they had access to the roof when they submitted the join form")
    referral: Optional[StrictStr] = Field(default=None, description="The \"How did you hear about us?\" information provided to us when the member submitted the join form")
    notes: Optional[StrictStr] = Field(default=None, description="A free-form text description of this Install, to track any additional information. For Installs imported from the spreadsheet, this starts with a formatted block of information about the import process and original spreadsheet data. However this structure can be changed by admins at any time and should not be relied on by automated systems. ")
    diy: Optional[StrictBool] = Field(default=None, description="Was this install conducted by the member themselves? If not, it was done by a volunteer installer on their behalf")
    node: Optional[InstallNode] = None
    building: Optional[InstallBuilding] = None
    member: Optional[InstallMember] = None
    additional_members: Optional[List[InstallAdditionalMembersInner]] = Field(default=None, description="Any additional members associated with this install. E.g. roommates, parents, caretakers etc. Anyone that might contact us on behalf of this install belongs here")
    __properties: ClassVar[List[str]] = ["id", "request_date", "install_fee_billing_datum", "install_number", "status", "ticket_number", "install_date", "abandon_date", "unit", "roof_access", "referral", "notes", "diy", "node", "building", "member", "additional_members"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PatchedInstall from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "id",
            "install_number",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of install_fee_billing_datum
        if self.install_fee_billing_datum:
            _dict['install_fee_billing_datum'] = self.install_fee_billing_datum.to_dict()
        # override the default output from pydantic by calling `to_dict()` of node
        if self.node:
            _dict['node'] = self.node.to_dict()
        # override the default output from pydantic by calling `to_dict()` of building
        if self.building:
            _dict['building'] = self.building.to_dict()
        # override the default output from pydantic by calling `to_dict()` of member
        if self.member:
            _dict['member'] = self.member.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in additional_members (list)
        _items = []
        if self.additional_members:
            for _item_additional_members in self.additional_members:
                if _item_additional_members:
                    _items.append(_item_additional_members.to_dict())
            _dict['additional_members'] = _items
        # set to None if ticket_number (nullable) is None
        # and model_fields_set contains the field
        if self.ticket_number is None and "ticket_number" in self.model_fields_set:
            _dict['ticket_number'] = None

        # set to None if install_date (nullable) is None
        # and model_fields_set contains the field
        if self.install_date is None and "install_date" in self.model_fields_set:
            _dict['install_date'] = None

        # set to None if abandon_date (nullable) is None
        # and model_fields_set contains the field
        if self.abandon_date is None and "abandon_date" in self.model_fields_set:
            _dict['abandon_date'] = None

        # set to None if unit (nullable) is None
        # and model_fields_set contains the field
        if self.unit is None and "unit" in self.model_fields_set:
            _dict['unit'] = None

        # set to None if referral (nullable) is None
        # and model_fields_set contains the field
        if self.referral is None and "referral" in self.model_fields_set:
            _dict['referral'] = None

        # set to None if notes (nullable) is None
        # and model_fields_set contains the field
        if self.notes is None and "notes" in self.model_fields_set:
            _dict['notes'] = None

        # set to None if diy (nullable) is None
        # and model_fields_set contains the field
        if self.diy is None and "diy" in self.model_fields_set:
            _dict['diy'] = None

        # set to None if node (nullable) is None
        # and model_fields_set contains the field
        if self.node is None and "node" in self.model_fields_set:
            _dict['node'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PatchedInstall from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "request_date": obj.get("request_date"),
            "install_fee_billing_datum": InstallInstallFeeBillingDatum.from_dict(obj["install_fee_billing_datum"]) if obj.get("install_fee_billing_datum") is not None else None,
            "install_number": obj.get("install_number"),
            "status": obj.get("status"),
            "ticket_number": obj.get("ticket_number"),
            "install_date": obj.get("install_date"),
            "abandon_date": obj.get("abandon_date"),
            "unit": obj.get("unit"),
            "roof_access": obj.get("roof_access") if obj.get("roof_access") is not None else False,
            "referral": obj.get("referral"),
            "notes": obj.get("notes"),
            "diy": obj.get("diy"),
            "node": InstallNode.from_dict(obj["node"]) if obj.get("node") is not None else None,
            "building": InstallBuilding.from_dict(obj["building"]) if obj.get("building") is not None else None,
            "member": InstallMember.from_dict(obj["member"]) if obj.get("member") is not None else None,
            "additional_members": [InstallAdditionalMembersInner.from_dict(_item) for _item in obj["additional_members"]] if obj.get("additional_members") is not None else None
        })
        return _obj


